pragma solidity ^0.8.0;

//import '@openzeppelin/contracts/access/Ownable.sol';
//import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
//import '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';

contract Sloth is ERC721, ERC721Enumerable, Ownable {
  using Strings for uint256;
  bool public _isWhiteListSaleActive = false;
  bool public _isSaleActive = false;

  // Constants
  uint256 constant public MAX_SUPPLY = 2022;//總量
  uint256 public mintPrice = 0.08 ether;//mint 價錢
  uint256 public whiteListPrice = 0.06 ether;//白名單價錢
  bool public iswhitelist = true;
  uint256 public maxwhitelistBalance=2;//白名單上限
  uint256 public revealTimeStamp = block.timestamp+86400*14 ; //解盲天數


  string private _baseURIExtended;
  string private _preRevealURI;

  mapping(address => bool) public whiteList;
  

  event TokenMinted(uint256 supply);

  constructor() ERC721('Swag Sloth', 'SLOTH') {}//token名字

  function flipWhiteListSaleActive() public onlyOwner {
    _isWhiteListSaleActive = !_isWhiteListSaleActive;
  }//是否開始公售
  
  function flipSaleActive() public onlyOwner {
    _isSaleActive = !_isSaleActive;
  }//是否開始白名單販售


  function setMintPrice(uint256 _mintPrice) public onlyOwner {
    mintPrice = _mintPrice;
  }//重新設定公售價錢

  function setWhiteListPrice(uint256 _whiteListPrice) public onlyOwner {
    whiteListPrice = _whiteListPrice;
  }//重新設定白名單價錢



  function setWhiteList(address[] calldata _whiteList) external onlyOwner {
    for(uint i = 0; i < _whiteList.length; i++) {
      whiteList[_whiteList[i]] = iswhitelist;
    }
  }//設定白名單地址


  function withdraw(address to) public onlyOwner {
    uint256 balance = address(this).balance;
    payable(to).transfer(balance);
  }//領錢

  function preserveMint(uint numSloths, address to) public onlyOwner {
    require(totalSupply() + numSloths <= MAX_SUPPLY, 'Preserve mint would exceed max supply');
    _mintSloth(numSloths, to);
    emit TokenMinted(totalSupply());
  }//項目方自己mint

  function getTotalSupply() public view returns (uint256) {
    return totalSupply();
  }//目前mint的量

  function getSlothByOwner(address _owner) public view returns (uint256[] memory) {
    uint256 tokenCount = balanceOf(_owner);
    uint256[] memory tokenIds = new uint256[](tokenCount);
    for (uint256 i; i < tokenCount; i++) {
      tokenIds[i] = tokenOfOwnerByIndex(_owner, i);
    }
    return tokenIds;
  }//查詢tokenid


  function mintSloths(uint numSloths) public payable {
    require(_isSaleActive, 'Sale must be active to mint Sloths');
    require(totalSupply() + numSloths <= MAX_SUPPLY, 'Sale would exceed max supply');
    require(numSloths * mintPrice <= msg.value, 'Not enough ether sent');
    _mintSloth(numSloths, msg.sender);
    emit TokenMinted(totalSupply());
  }//mint ＮＦＴ
  
  function setRevealTimestamp(uint256 newRevealTimeStamp) external onlyOwner {
    revealTimeStamp = newRevealTimeStamp;
  }//設定解盲時間

  function whiteListMintSloths(uint numSloths) public payable {
    require(_isWhiteListSaleActive, 'Sale must be active to mint Sloths');
    require(totalSupply() + numSloths <= MAX_SUPPLY, 'Sale would exceed max supply');
    require(balanceOf(msg.sender) + numSloths <= maxwhitelistBalance, 'Sale would exceed max Whitelist balance');
    uint256 price = whiteListPrice;
    require(numSloths * price <= msg.value, 'Not enough ether sent');
    if (whiteList[msg.sender] == true) {
    price = whiteListPrice;
    whiteList[msg.sender] = false;
    } 
    else  {
    revert('Not in white list');
    }
    _mintSloth(numSloths, msg.sender);
    emit TokenMinted(totalSupply());
  }//白名單mint


  function _mintSloth(uint256 numSloths, address recipient) internal {
    uint256 supply = totalSupply();
    for (uint256 i = 0; i < numSloths; i++) {
      _safeMint(recipient, supply + i);
    }
  }

  function setBaseURI(string memory baseURI_) external onlyOwner {
    _baseURIExtended = baseURI_;
  }//設定tokenbase uri

  function _baseURI() internal view virtual override returns (string memory) {
    return _baseURIExtended;
  }

  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');
    if (totalSupply() >= MAX_SUPPLY || block.timestamp >= revealTimeStamp) {
        return string(abi.encodePacked(_baseURI(), tokenId.toString(), ".json"));
    }
    {
      return _preRevealURI;
    }
  }//顯示token uri

  function setPreRevealURI(string memory preRevealURI) external onlyOwner {
    _preRevealURI = preRevealURI;
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal override(ERC721, ERC721Enumerable) {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  function supportsInterface(bytes4 interfaceId)
    public
    view
    override(ERC721, ERC721Enumerable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }
}
